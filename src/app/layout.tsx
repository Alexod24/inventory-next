// src/app/layout.tsx
// ESTE ES UN SERVER COMPONENT POR DEFECTO. NO LLEVA "use client";

import { Outfit } from "next/font/google";
import "./globals.css";

import { SidebarProvider } from "@/context/SidebarContext";
import { ThemeProvider } from "@/context/ThemeContext";
import { UserProvider, UserProfile } from "@/context/UserContext"; // Importamos UserProfile

// Importa el cliente de Supabase para el LADO DEL SERVIDOR
import { createServerSupabaseClient } from "@/lib/supabaseServerClient";
// Importa el proveedor de sesión de Supabase (este SÍ es un Client Component)
import SupabaseSessionProvider from "@/components/SupabaseSessionProvider";
// Importa el componente Client que aplicará las clases de tema al <body>
import ThemeBodyApplicator from "@/components/ThemeBodyApplicator";

const outfit = Outfit({
  subsets: ["latin"],
});

// Metadatos de la aplicación
export const metadata = {
  title: "Inventory Next App",
  description: "Generated by create next app",
};

// La función RootLayout DEBE ser async para poder usar 'await'
export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  // 1. Obtener la sesión de Supabase en el LADO DEL SERVIDOR
  const supabase = await createServerSupabaseClient();

  // --- LOGS DE DEPURACIÓN (LOS DEJAMOS POR AHORA) ---
  console.log(
    "RootLayout: Objeto 'supabase' después de createServerSupabaseClient:",
    supabase
  );
  console.log(
    "RootLayout: Propiedad 'supabase.auth' después de createServerSupabaseClient:",
    supabase?.auth
  );

  // --- CORRECCIÓN DE SEGURIDAD ---
  // 1. Obtenemos el *usuario* de forma segura, como recomienda la advertencia.
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // 2. Si el usuario existe, *entonces* obtenemos la sesión completa para pasarla al cliente.
  //    Si el usuario no existe, la sesión es null.
  const {
    data: { session },
  } = user ? await supabase.auth.getSession() : { data: { session: null } };
  // --- FIN DE LA CORRECCIÓN ---

  let userDataForContext: UserProfile | null = null; // Inicializa con null

  // 3. Basamos TODA la lógica en el objeto 'user' (verificado) en lugar de 'session.user'
  if (user) {
    // Si hay una sesión activa, intenta obtener el rol del usuario de la tabla 'usuarios'
    console.log(
      "RootLayout: Sesión activa (verificada por getUser), intentando obtener rol para user ID:",
      user.id // Usamos user.id
    );
    const { data: profile, error: profileError } = await supabase
      .from("usuarios")
      .select("nombre, rol") // Selecciona el nombre y el rol
      .eq("id", user.id) // Usamos user.id
      .single();

    if (profileError) {
      console.error(
        "RootLayout: Error al obtener perfil de usuario:",
        profileError.message
      );
      // Si hay un error al obtener el perfil, aún podemos pasar la información básica de Auth
      userDataForContext = {
        id: user.id,
        email: user.email,
        nombre: null, // No se pudo obtener el nombre
        rol: null, // No se pudo obtener el rol
      };
    } else if (profile) {
      userDataForContext = {
        id: user.id,
        email: user.email,
        nombre: profile.nombre, // Pasa el nombre obtenido del perfil
        rol: profile.rol, // Pasa el rol obtenido del perfil
      };
      console.log(
        "RootLayout: Perfil de usuario cargado. Rol:",
        profile.rol,
        "Nombre:",
        profile.nombre
      );
    } else {
      console.warn(
        "RootLayout: No se encontró perfil en la tabla 'usuarios' para el ID:",
        user.id // Usamos user.id
      );
      // Si no se encuentra el perfil, el usuario sigue logueado en Auth, pero sin rol específico de la app.
      userDataForContext = {
        id: user.id,
        email: user.email,
        nombre: null, // No hay nombre de perfil
        rol: null, // No hay rol de perfil
      };
    }
  } else {
    console.log("RootLayout: No hay sesión activa (verificado por getUser).");
  }

  return (
    <html lang="en">
      <body className={outfit.className} suppressHydrationWarning>
        <ThemeProvider>
          <SidebarProvider>
            <UserProvider initialUser={userDataForContext}>
              <ThemeBodyApplicator />

              {/* 4. Pasamos la 'session' (que será 'null' si no hay usuario)
                  al proveedor del cliente. Esto es correcto. */}
              <SupabaseSessionProvider initialSession={session}>
                {children}
              </SupabaseSessionProvider>
            </UserProvider>
          </SidebarProvider>
        </ThemeProvider>
      </body>
    </html>
  );
}
